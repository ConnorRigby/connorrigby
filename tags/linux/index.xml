<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>linux on cone.codes</title><link>https://cone.codes/tags/linux/</link><description>Recent content in linux on cone.codes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Creative Commons Attribution 4.0 International</copyright><lastBuildDate>Fri, 22 Apr 2022 17:16:27 -0600</lastBuildDate><atom:link href="https://cone.codes/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>CAN Link Part 4</title><link>https://cone.codes/posts/can-link-pt-4/</link><pubDate>Fri, 22 Apr 2022 17:16:27 -0600</pubDate><guid>https://cone.codes/posts/can-link-pt-4/</guid><description>After finishing up another project this week, I realized that arbitrary dimensions I picked for it fit inside the dimensions of the CAN Link project.
I spent a bit of time mocking the i.MX6 device up on the PCB and it fit really well. The width of both PCBs just happened to be the same. This will make porting the device to the i.MX platform really easy assuming the devboard actually works.</description><content>&lt;p>After finishing up &lt;a href="https://cone.codes/posts/imx6-devboard/">another project&lt;/a> this week, I realized that arbitrary dimensions I picked for it fit inside the dimensions of the CAN Link project.&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/957852929254113300/966413284305694760/unknown.png" alt="imx mockup">&lt;/p>
&lt;p>I spent a bit of time mocking the i.MX6 device up on the PCB and it fit &lt;em>really&lt;/em> well. The width of both PCBs just &lt;em>happened&lt;/em> to be the same. This will make porting the device to the i.MX platform really easy assuming the devboard actually works. I didn&amp;rsquo;t want to actually finalize this design yet because I still don&amp;rsquo;t know if the new circuit actually works.&lt;/p>
&lt;p>What I did realize during this exercise however, is that all the components that are common between both designs would not need to move at all. I could even separate the design into two separate PCBS!&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/957852929254113300/966441204122259486/unknown.png" alt="pcb2">&lt;/p>
&lt;p>So I started scheming on changes to the top half of the board. I figured there must be a suitable way to connect two PCBs horizantally. This was surprisingly difficult to find in a way that didn&amp;rsquo;t look really ugly. (yeah; that &lt;em>was&lt;/em> the primary deciding factor)&lt;/p>
&lt;p>&lt;img src="https://media.digikey.com/Photos/Phoenix%20Photos/1714875.jpg" alt="phoenix-1714875">&lt;/p>
&lt;p>The coolest part about this component is that it&amp;rsquo;s a pretty &amp;ldquo;standard&amp;rdquo; pin spacing meaning a 1.27mm socket fits in place of this locking connector&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/957852929254113300/966441826343084062/unknown.png" alt="1p27mm-socket">&lt;/p>
&lt;p>Since this was mostly just a job of removing a lot of components, I didnt have much else to do here other than plumb up the new connector. Most of the signals were already going through this route anyway; I just terminated them, sliced the board in half and it was pretty much done. I sprinkled some silkscreen indicating what each pin does and got to prepping for fabrication. I was planning on having JLCPCB assemble the board, but none of difficult to solder components are &lt;code>basic parts&lt;/code>. I had them fabricate it for a grand total of $38. Once my i.MX 6 board is confirmed functioning, I&amp;rsquo;ll be designing the bottom half of this board. Ideally &amp;ldquo;design&amp;rdquo; is used lightly here, it should be really simple.&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/694859292456517675/967201995104608296/unknown.png?width=1529&amp;amp;height=1137" alt="finished-pcb">
&lt;img src="https://media.discordapp.net/attachments/694859292456517675/967201995486281798/unknown.png?width=1533&amp;amp;height=1136" alt="finished-pcb-back">&lt;/p></content></item><item><title>i.MX6 Development board</title><link>https://cone.codes/posts/imx6-devboard/</link><pubDate>Thu, 21 Apr 2022 15:49:46 -0600</pubDate><guid>https://cone.codes/posts/imx6-devboard/</guid><description>While waiting on PCBs to come in the mail for other projects, a friend of mine linked me something I only wish I had found sooner. An i.MX6 SOC. Most importantly, it can be found in stock! At JLCPCB nonetheless. This prompted me to consider; Could I make a Linux capable device using only components at JLCPCB? Well, spoiler alert - no. But I tried anyway.
The Major Challenge This was a cool discovery - I&amp;rsquo;ve always wanted a low cost platform I can use for small one-off designs.</description><content>&lt;p>While waiting on PCBs to come in the mail for other &lt;a href="https://cone.codes/posts/can-link-pt-3/">projects&lt;/a>, a friend of mine linked me something I only wish I had found sooner. An &lt;a href="https://jlcpcb.com/parts/componentSearch?isSearch=true&amp;amp;searchTxt=C1555487">i.MX6 SOC&lt;/a>. Most importantly, it can be found in stock! At JLCPCB nonetheless. This prompted me to consider; Could I make a Linux capable device using only components at JLCPCB? Well, spoiler alert - no. But I tried anyway.&lt;/p>
&lt;h2 id="the-major-challenge">The Major Challenge&lt;/h2>
&lt;p>This was a cool discovery - I&amp;rsquo;ve always wanted a low cost platform I can use for small one-off designs. What originally hoped the OSD335xx or OSD32-MP1 platforms could offer me. The global chip shortage really stuffed that one up for me, a hobbiest. What&amp;rsquo;s cool about the i.MX platforms, is they are (mostly) pin compatible. This means I can create a general &amp;ldquo;core&amp;rdquo; module that I can simply plop down on a design and be on my way to prototypes. The only problem - I&amp;rsquo;ve never routed DRAM before. The concept has always terrified me as someone with no propper training in this stuff. I knew the general concepts, some &lt;em>address&lt;/em> wires, some &lt;em>data&lt;/em> wires, maybe some &lt;em>clocks&lt;/em>? Are those differential pairs? What about termination resistors? Something about inductance? Okay so I needed a bit more than a primer. I spent all my free time researching this subject for about 3 days. After reading countless arguments on StackOverflow or watching every KiCAD tutorial on Youtube, I didn&amp;rsquo;t feel that much more confident so I figured it was time to just start failing. Which I did. A lot.&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/957852929254113300/965619565511974963/unknown.png" alt="kicad-pcb-view">&lt;/p>
&lt;p>I didn&amp;rsquo;t take many screenshots throughout this process like I normally do, but this about sums the experience up.
Eventually I managed to get the entire circuit routed. NXP has a few app notes and some reference designs that I used as much as I could.&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/957852929254113300/965655287711297616/unknown.png" alt="kicad-3d-view">&lt;/p>
&lt;p>During this process, I found a few really useful resources:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/jaydcarlson/mxiot">mxiot&lt;/a> - A devboard using this exact SOC. I used this a lot in the beginning for the schematic and general understanding of the platform.&lt;/li>
&lt;li>&lt;a href="https://github.com/EnzoRF/nanoberry">nanoberry&lt;/a> - More of the above, but developed in KiCAD. I used this &lt;strong>a lot&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="the-easy-parts">The Easy parts&lt;/h2>
&lt;p>After getting the high speed DRAM routed, the rest of the process was pretty familiar. I plopped down some connectors I already had laying around in my office for I/O and routed in a WiFi module. This was all that was really needed to test the device out. As I mentioned earlier, the i.MX 6 series are &amp;ldquo;pin compatible&amp;rdquo; with different models. What this means is that although I&amp;rsquo;m currently using the &lt;code>6ULZ&lt;/code> version for this now, I could in theory use any of the other devices in this series using the same BGA289 package. So in the name of planning ahead, I added a few more things. Because I eventually want to use this circuit to replace the CM4 in &lt;a href="https://cone.codes/posts/can-link-pt-2/">an another project&lt;/a>, I added a CAN transciever and a DB9 connector (which is for better or worse, standard) and of course a buck converter to get 12v down to 5v.&lt;/p>
&lt;p>I also added a couple other things, for no good reason other than because they were in the library and easy to add - a RFM69 SPI radio, and a RP2040.
&lt;img src="https://media.discordapp.net/attachments/957852929254113300/966168700078162001/unknown.png" alt="back-side">&lt;/p>
&lt;h2 id="fabrication">Fabrication&lt;/h2>
&lt;p>The original reason I toook this on was because I thought I could have it fabricated by JLCPCB. At the very beginning, I checked their &lt;a href="https://jlcpcb.com/capabilities/Capabilities">capabilities&lt;/a>
&lt;img src="https://media.discordapp.net/attachments/957852929254113300/966840182848495636/unknown.png?width=2160&amp;amp;height=616" alt="caps">
which claim to support 0.2/0.4 vias. What it doesn&amp;rsquo;t say, is that when you actually go to order boards, you have to select a special option that more than doubles the price of the board, and it&amp;rsquo;s still right at the limit of their capabilities. So I ultimately went with PCBWay since I had coupons and the price came out to be cheaper overall with them instead of JLCPCB.&lt;/p>
&lt;p>All said and done, 2 fully populated prototypes cost me $350 shipped to my house. The BOM cost is about $50 per device. I didn&amp;rsquo;t define a firm price that I wanted, but $350 is more than I wanted, but still not &lt;em>that&lt;/em> bad. The coolest part about it is that all components were readily available with no signifigant lead time.&lt;/p>
&lt;p>Check back in a month when they arrive and I find out if I can copy/paste out of a reference design well enough to get this device to boot.&lt;/p></content></item><item><title>CAN Link Part 3</title><link>https://cone.codes/posts/can-link-pt-3/</link><pubDate>Wed, 13 Apr 2022 06:29:07 -0600</pubDate><guid>https://cone.codes/posts/can-link-pt-3/</guid><description>Another day, another hardware redesign. I&amp;rsquo;m getting pretty good at it by this point, but this should be the last major revision. It&amp;rsquo;s been sent to production at PCBWay and I&amp;rsquo;ve ordered components, so there&amp;rsquo;s no going back now.
Right before clicking buy on the last revision&amp;rsquo;s PCBs, a friend of mine tricked me into breaking the remaining pins out on the board. This concept was simple enough, just find connectors that are in stock and plumb up the remaining pins.</description><content>&lt;p>Another day, another hardware redesign. I&amp;rsquo;m getting pretty good at it by this point, but this should be the last major revision. It&amp;rsquo;s been sent to production at PCBWay and I&amp;rsquo;ve ordered components, so there&amp;rsquo;s no going back now.&lt;/p>
&lt;p>Right before clicking buy on the last revision&amp;rsquo;s PCBs, a friend of mine tricked me into breaking the remaining pins out on the board. This concept was simple enough, just find connectors that are in stock and plumb up the remaining pins. What i ended up with at first came out looking pretty cool&lt;/p>
&lt;p>&lt;img src="https://cdn.discordapp.com/attachments/957852929254113300/962854818156773406/unknown.png" alt="pcb pre-revision">&lt;/p>
&lt;p>I mulled on this design overnight, planning to order it the next day. That is, until a different friend tricked me yet again. For good reason tho, look at &lt;a href="https://www.te.com/usa-en/product-CAT-D485-EN17.html?q=&amp;amp;n=41628&amp;amp;type=products&amp;amp;samples=N&amp;amp;inStoreWithoutPL=false&amp;amp;instock=N">these enclosures&lt;/a> and the accompanying &lt;a href="https://www.te.com/usa-en/product-DTM1312PA12PBR008.html">connector&lt;/a>.&lt;/p>
&lt;p>&lt;img src="https://www.te.com/content/dam/te-com/catalog/part/CAT/D48/5EN/CAT-D485-EN17-t2.jpg/jcr:content/renditions/product-details.png" alt="enclosure">
&lt;img src="https://www.te.com/content/dam/te-com/catalog/part/DTM/131/2PA/DTM1312PA12PBR008-t1.jpg/jcr:content/renditions/product-details.png" alt="connector">&lt;/p>
&lt;p>Only problem, my current design was no where near fitting&lt;/p>
&lt;p>&lt;img src="https://cdn.discordapp.com/attachments/957852929254113300/963054779372814366/unknown.png" alt="pcb-enclosure-disagreement">&lt;/p>
&lt;p>So of course that lead me to the final redesign. I&amp;rsquo;m getting pretty quick at it by now. It only took me a few hours on Monday afternoon. The gritty details of this revision weren&amp;rsquo;t that interesting. The only net-new part I chose was &lt;a href="https://octopart.com/uc-31pffp-qs8001-amphenol+ltw-81782226">this waterproof USB connector&lt;/a>. It took me a little bit to deside where exactly to put it, but ultimately I decided the opposite side of the main connectors was suitable. This will require modification of the enclosure, but it should be simple.&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/957852929254113300/963064627242078248/unknown.png?width=514&amp;amp;height=605" alt="PCB with USB">&lt;/p>
&lt;p>Nothing else was really that interesting here, so here&amp;rsquo;s a few beauty shots.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">&lt;img src="https://media.discordapp.net/attachments/957852929254113300/963236288918585404/unknown.png?width=467&amp;amp;height=605" alt="front-no-case">&lt;/td>
&lt;td style="text-align:right">&lt;img src="https://media.discordapp.net/attachments/957852929254113300/963237763535224842/unknown.png?width=519&amp;amp;height=605" alt="front-case">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;img src="https://media.discordapp.net/attachments/957852929254113300/963236289325461574/unknown.png?width=467&amp;amp;height=605" alt="back-no-case">&lt;/td>
&lt;td style="text-align:right">&lt;img src="https://media.discordapp.net/attachments/957852929254113300/963237763874955314/unknown.png?width=539&amp;amp;height=604" alt="back-case">&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>I&amp;rsquo;m also absolutely obsessed with the &amp;ldquo;export STEP&amp;rdquo; feature of KiCAD. I even installed Fusion 360 for the first time to play with the model.&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/957852929254113300/963603624628469770/unknown.png?width=807&amp;amp;height=418" alt="cad">&lt;/p>
&lt;p>In other tangentally related news, I made the repository &lt;a href="https://github.com/miata-bot/can-link">public&lt;/a>. Stay tuned for next time, I plan to write up a quick post on &amp;ldquo;porting&amp;rdquo; all the existing software to the new hardware platform.&lt;/p></content></item><item><title>CAN Link Part 2</title><link>https://cone.codes/posts/can-link-pt-2/</link><pubDate>Fri, 08 Apr 2022 15:19:25 -0600</pubDate><guid>https://cone.codes/posts/can-link-pt-2/</guid><description>Last week, I closed with
I ordered a few OSD335X chips on Aliexpress. Tune back in next week to see if they show up or not.
Well, it&amp;rsquo;s next week, and my order got canceled. I ordered s&amp;rsquo;more from other places, and it was canceled. I Couldn&amp;rsquo;t even find anywhere that had a single SOM for me to buy. Best I could find was Minimum Order Quantity of 250 pieces. So I did what any reasonable person would do; Desoldered some from old, broken boards.</description><content>&lt;p>Last week, I closed with&lt;/p>
&lt;blockquote>
&lt;p>I ordered a few OSD335X chips on Aliexpress. Tune back in next week to see if they show up or not.&lt;/p>
&lt;/blockquote>
&lt;p>Well, it&amp;rsquo;s next week, and my order got canceled. I ordered s&amp;rsquo;more from other places, and it was canceled. I Couldn&amp;rsquo;t even find anywhere that had a &lt;em>single&lt;/em> SOM for me to buy. Best I could find was &lt;a href="https://en.wikipedia.org/wiki/MOQ">Minimum Order Quantity&lt;/a> of 250 pieces. So I did what any reasonable person would do; Desoldered some from old, broken boards.&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/643947340453118019/961053924801011712/IMG_20220405_180317.jpg?width=759&amp;amp;height=1012" alt="desoldered-som">.&lt;/p>
&lt;p>Then after sleeping on the idea of desoldering 10+ of these, I realized this probably isn&amp;rsquo;t the move for this project.&lt;/p>
&lt;p>As a side note&lt;/p>
&lt;blockquote>
&lt;p>FS: 1 (one) OSD3558-512M-BAS, slightly used $1000 OBO&lt;/p>
&lt;/blockquote>
&lt;p>So I had a look through &lt;a href="https://octopart.com/">Octopart&lt;/a>, and decided that this project was dumb and gave up.&lt;/p>
&lt;h2 id="redesigning-the-pcb">Redesigning the PCB&lt;/h2>
&lt;p>Then I made some coffee, sat down, and got to work redesigning the PCB for a &lt;a href="https://www.raspberrypi.com/products/compute-module-4/">Raspberry Pi Compute Module&lt;/a>. These are really cool modules, but not really specced for this application. They are obviously targeted at media applications, not industrial control protocols or much/any interaction with the outside world. Buuuut they do have one good thing going for them - I can get a few of them. Below is a table showing some of the important differences in the main CPUs.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">SOM&lt;/th>
&lt;th style="text-align:center">CPU Clock Speed&lt;/th>
&lt;th style="text-align:center">CPU Cores&lt;/th>
&lt;th style="text-align:center">RAM&lt;/th>
&lt;th style="text-align:center">Available PWM&lt;/th>
&lt;th style="text-align:center">USB Ports&lt;/th>
&lt;th style="text-align:center">Native CAN support&lt;/th>
&lt;th style="text-align:center">CSI (camera) ports&lt;/th>
&lt;th style="text-align:center">DSI (display) ports&lt;/th>
&lt;th style="text-align:center">HDMI ports&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">OSD335x&lt;/td>
&lt;td style="text-align:center">900 MHz&lt;/td>
&lt;td style="text-align:center">1&lt;/td>
&lt;td style="text-align:center">512MB&lt;/td>
&lt;td style="text-align:center">a lot&lt;/td>
&lt;td style="text-align:center">2&lt;/td>
&lt;td style="text-align:center">yes&lt;/td>
&lt;td style="text-align:center">0&lt;/td>
&lt;td style="text-align:center">0&lt;/td>
&lt;td style="text-align:center">0&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">CM4&lt;/td>
&lt;td style="text-align:center">1.4 GHz&lt;/td>
&lt;td style="text-align:center">4&lt;/td>
&lt;td style="text-align:center">1-8 GB&lt;/td>
&lt;td style="text-align:center">2 (3 are required)&lt;/td>
&lt;td style="text-align:center">1 (2 were desired )&lt;/td>
&lt;td style="text-align:center">no (required)&lt;/td>
&lt;td style="text-align:center">2&lt;/td>
&lt;td style="text-align:center">2&lt;/td>
&lt;td style="text-align:center">2&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Soooo, while it technically is easier to obtain, the next issue is finding external components to do all the stuff I don&amp;rsquo;t need, notably CAN and RGB (the literal only requirements for this project).&lt;/p>
&lt;p>Irritated, I hopped back onto OctoPart and started component hunting. First up was something about the PWM issue. I had two ideas for this, so to prevent further redesigns I decided to lay out both, just in case. The most straightforward solution is using some sort of IO Expander chip. I knew of one right off the top of my head: &lt;a href="https://www.futureelectronics.com/p/semiconductors--analog--drivers--led-drivers-linear-mode/PCA9685PW-112-nxp-1019213?utm_source=octopart&amp;amp;utm_medium=aggregator&amp;amp;utm_campaign=crossref&amp;amp;utm_term=PCA9685PW%2C112">NXP PCA9685PW,112&lt;/a>. It&amp;rsquo;s made specifically for controlling RGB LEDs via &lt;a href="https://en.wikipedia.org/wiki/I%C2%B2C">I²C&lt;/a>. Features include: &lt;a href="https://github.com/torvalds/linux/blob/master/drivers/pwm/pwm-pca9685.c">already having a driver in Linux&lt;/a> and being pretty straight forward to design around. Bad news is it&amp;rsquo;s really popular so I can&amp;rsquo;t find it anywhere. So, the backup then: &lt;a href="https://www.raspberrypi.com/products/raspberry-pi-pico/">A Raspberry Pi Pico&lt;/a>. I originally planned on using just the RP2040 chip, but you guessed it - out of stock. I connected it to the CM4 via I²C, and slapped it down on the board.&lt;/p>
&lt;p>The other missing main component is something that speaks &lt;a href="https://en.wikipedia.org/wiki/CAN_bus">CAN&lt;/a>. Again, I already had an idea for this as well. &lt;a href="https://www.microchip.com/en-us/product/MCP2515">The MCP2515&lt;/a>. It&amp;rsquo;s old, it&amp;rsquo;s not recommended for new designs, and I have a bunch of them in different packages on the shelf. Not much else to say about this chip other than because I have a bunch of them in 2 different packages, I plopped down a footprint for both of them on the board so I can just solder whichever without spinning a new board:&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/643947340453118019/961786045333119076/unknown.png" alt="MCP Dual footprints">&lt;/p>
&lt;p>In the shot above, &lt;code>U8&lt;/code> and &lt;code>U5&lt;/code> are both a &lt;code>MCP2515&lt;/code>, just in two different packages. (also photo&amp;rsquo;d is the &lt;code>pca9685&lt;/code> chip above.)&lt;/p>
&lt;p>The other thing I tested this week was the &amp;ldquo;hack&amp;rdquo; of using a set of BSS138 N channel transistors to do the LED PWMing.&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/643947340453118019/960593404012675132/IMG_20220404_113438.jpg?width=759&amp;amp;height=1012" alt="BSS138 prototype">&lt;/p>
&lt;p>As it turns out, they are not suitable for this application. When I threw these prototype boards on my bench supply connected to the prototype, I managed to melt the transistor at 12V @ 2A. I &lt;strong>could&lt;/strong> just limit the brightness in software, but since I&amp;rsquo;m spinning the board anyway, I replaced them with a set of &lt;a href="https://en.wikipedia.org/wiki/MOSFET">Mosfets&lt;/a>.&lt;/p>
&lt;p>Finally, after about a day of rerouting and updating everything, I was left with the new PCB. The best part, 93% procurable component selection.&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/957852929254113300/962089782127788072/unknown.png" alt="octopart-bom">&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/957852929254113300/962088847506800690/unknown.png" alt="rerouted-pcb-final">&lt;/p>
&lt;h2 id="conclusions">Conclusions&lt;/h2>
&lt;p>I&amp;rsquo;m not super happy that I had to go through all this, but for what it&amp;rsquo;s worth, using the CM4 module was &lt;em>very&lt;/em> easy, Even if it&amp;rsquo;s not the perfect selection. I really wanted to use the OSD335x chip since it&amp;rsquo;s a really cool chip, and has all the stuff I need built right into it. I&amp;rsquo;m sure I &lt;strong>could&lt;/strong> have hunted around for another SOM. Several come to mind, the OSD32MP1, Most of the IMX line, etc. But upon quick searches, they are all just as hard to get as the OS335x.
The other interesting part of all of this is that the BOM price actually went down by quite a bit. I wasn&amp;rsquo;t keeping super good track of this since most of the components I selected for the original design are out of stock and therefor artifically inflated in price. It&amp;rsquo;s kind of frustrating that it was easier to use something designed for set top boxes than it was to use something purpose built for my project but oh well.&lt;/p>
&lt;p>Tune back in next week to see if I give entirely for real this time.&lt;/p></content></item><item><title>Using PWM with Nerves</title><link>https://cone.codes/posts/nerves-pwm/</link><pubDate>Mon, 04 Apr 2022 19:07:10 -0600</pubDate><guid>https://cone.codes/posts/nerves-pwm/</guid><description>TLDR This is probably what you need. Take it and modify it as you see fit.
defmodule MyAPP.PWM do @moduledoc &amp;#34;&amp;#34;&amp;#34; Basic control pwm: ehrpwm1A == pwmchip2/pwm0 (LED R) ehrpwm1B == pwmchip2/pwm1 (LED G) ehrpwm2A == pwmchip0/pwm0 (LED B) &amp;#34;&amp;#34;&amp;#34; @pwms [ led_r: {2, 0}, led_g: {2, 1}, led_b: {0, 0}, ] # Period for 25kHz PWM @period 40_000 def init() do @pwms |&amp;gt; Enum.each(fn {_pwm, {chip, pin}} -&amp;gt; File.write(&amp;#34;/sys/class/pwm/pwmchip#{chip}/export&amp;#34;, to_string(pin)) File.</description><content>&lt;h2 id="tldr">TLDR&lt;/h2>
&lt;p>This is probably what you need. Take it and modify it as you see fit.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-elixir" data-lang="elixir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">defmodule&lt;/span> &lt;span style="color:#a6e22e">MyAPP.PWM&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@moduledoc&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> Basic control
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> pwm:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> ehrpwm1A == pwmchip2/pwm0 (LED R)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> ehrpwm1B == pwmchip2/pwm1 (LED G)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> ehrpwm2A == pwmchip0/pwm0 (LED B)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@pwms&lt;/span> [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">led_r&lt;/span>: {&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">led_g&lt;/span>: {&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">led_b&lt;/span>: {&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Period for 25kHz PWM&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@period&lt;/span> &lt;span style="color:#ae81ff">40_000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> init() &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@pwms&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">Enum&lt;/span>&lt;span style="color:#f92672">.&lt;/span>each(&lt;span style="color:#66d9ef">fn&lt;/span> {_pwm, {chip, pin}} &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">File&lt;/span>&lt;span style="color:#f92672">.&lt;/span>write(&lt;span style="color:#e6db74">&amp;#34;/sys/class/pwm/pwmchip&lt;/span>&lt;span style="color:#e6db74">#{&lt;/span>chip&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/export&amp;#34;&lt;/span>, to_string(pin))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">File&lt;/span>&lt;span style="color:#f92672">.&lt;/span>write(&lt;span style="color:#e6db74">&amp;#34;/sys/class/pwm/pwmchip&lt;/span>&lt;span style="color:#e6db74">#{&lt;/span>chip&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/pwm&lt;/span>&lt;span style="color:#e6db74">#{&lt;/span>pin&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/period&amp;#34;&lt;/span>, to_string(&lt;span style="color:#a6e22e">@period&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> period(pwm, period) &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {chip, pwm} &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Keyword&lt;/span>&lt;span style="color:#f92672">.&lt;/span>fetch!(&lt;span style="color:#a6e22e">@pwms&lt;/span>, pwm)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">File&lt;/span>&lt;span style="color:#f92672">.&lt;/span>write(&lt;span style="color:#e6db74">&amp;#34;/sys/class/pwm/pwmchip&lt;/span>&lt;span style="color:#e6db74">#{&lt;/span>chip&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/pwm&lt;/span>&lt;span style="color:#e6db74">#{&lt;/span>pwm&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/period&amp;#34;&lt;/span>, to_string(period))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> period(pwm) &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {chip, pwm} &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Keyword&lt;/span>&lt;span style="color:#f92672">.&lt;/span>fetch!(&lt;span style="color:#a6e22e">@pwms&lt;/span>, pwm)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">File&lt;/span>&lt;span style="color:#f92672">.&lt;/span>read!(&lt;span style="color:#e6db74">&amp;#34;/sys/class/pwm/pwmchip&lt;/span>&lt;span style="color:#e6db74">#{&lt;/span>chip&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/pwm&lt;/span>&lt;span style="color:#e6db74">#{&lt;/span>pwm&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/period&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">String&lt;/span>&lt;span style="color:#f92672">.&lt;/span>trim()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">String&lt;/span>&lt;span style="color:#f92672">.&lt;/span>to_integer()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> duty_cycle(pwm, duty_cycle) &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {chip, pwm} &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Keyword&lt;/span>&lt;span style="color:#f92672">.&lt;/span>fetch!(&lt;span style="color:#a6e22e">@pwms&lt;/span>, pwm)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">File&lt;/span>&lt;span style="color:#f92672">.&lt;/span>write(&lt;span style="color:#e6db74">&amp;#34;/sys/class/pwm/pwmchip&lt;/span>&lt;span style="color:#e6db74">#{&lt;/span>chip&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/pwm&lt;/span>&lt;span style="color:#e6db74">#{&lt;/span>pwm&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/duty_cycle&amp;#34;&lt;/span>, to_string(duty_cycle))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> duty_cycle(pwm) &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {chip, pwm} &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Keyword&lt;/span>&lt;span style="color:#f92672">.&lt;/span>fetch!(&lt;span style="color:#a6e22e">@pwms&lt;/span>, pwm)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">File&lt;/span>&lt;span style="color:#f92672">.&lt;/span>read!(&lt;span style="color:#e6db74">&amp;#34;/sys/class/pwm/pwmchip&lt;/span>&lt;span style="color:#e6db74">#{&lt;/span>chip&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/pwm&lt;/span>&lt;span style="color:#e6db74">#{&lt;/span>pwm&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/duty_cycle&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">String&lt;/span>&lt;span style="color:#f92672">.&lt;/span>trim()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">String&lt;/span>&lt;span style="color:#f92672">.&lt;/span>to_integer()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> enable(pwm, enable) &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {chip, pwm} &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Keyword&lt;/span>&lt;span style="color:#f92672">.&lt;/span>fetch!(&lt;span style="color:#a6e22e">@pwms&lt;/span>, pwm)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> enable &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> enable, &lt;span style="color:#e6db74">do&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">else&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">File&lt;/span>&lt;span style="color:#f92672">.&lt;/span>write(&lt;span style="color:#e6db74">&amp;#34;/sys/class/pwm/pwmchip&lt;/span>&lt;span style="color:#e6db74">#{&lt;/span>chip&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/pwm&lt;/span>&lt;span style="color:#e6db74">#{&lt;/span>pwm&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/enable&amp;#34;&lt;/span>, to_string(enable))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> enable(pwm) &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {chip, pwm} &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Keyword&lt;/span>&lt;span style="color:#f92672">.&lt;/span>fetch!(&lt;span style="color:#a6e22e">@pwms&lt;/span>, pwm)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">File&lt;/span>&lt;span style="color:#f92672">.&lt;/span>read!(&lt;span style="color:#e6db74">&amp;#34;/sys/class/pwm/pwmchip&lt;/span>&lt;span style="color:#e6db74">#{&lt;/span>chip&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/pwm&lt;/span>&lt;span style="color:#e6db74">#{&lt;/span>pwm&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/enable&amp;#34;&lt;/span>) &lt;span style="color:#f92672">|&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">String&lt;/span>&lt;span style="color:#f92672">.&lt;/span>trim()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="pwm-in-linux">PWM In Linux&lt;/h2>
&lt;p>I&amp;rsquo;ve always found using PWM in Linux unnecessarily tedious. When I first got started in Embedded Linux, I was coming from experience with Arduino. Love it or hate it, Arduino has this particular feature dialed in from the beginning.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setup&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">pinMode&lt;/span>(A0, OUTPUT);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">analogWrite&lt;/span>(A0, &lt;span style="color:#ae81ff">255&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>That&amp;rsquo;s it.&lt;/p>
&lt;p>Okay, so obviously it&amp;rsquo;s not a completely fair comparison, Arduino is a C++ framework, Linux is an operating system yada yada. Anyway here&amp;rsquo;s the snippit from the &lt;a href="https://www.kernel.org/doc/html/latest/driver-api/pwm.html">Linux
Kernel Documentation&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> pwm_lookup board_pwm_lookup[] &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">PWM_LOOKUP&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;tegra-pwm&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;pwm-backlight&amp;#34;&lt;/span>, NULL,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">50000&lt;/span>, PWM_POLARITY_NORMAL),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> __init &lt;span style="color:#a6e22e">board_init&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">pwm_add_table&lt;/span>(board_pwm_lookup, &lt;span style="color:#a6e22e">ARRAY_SIZE&lt;/span>(board_pwm_lookup));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Alright &lt;strong>what?&lt;/strong> So as it turns out that part of the document is completely irelevant to actually &lt;em>using&lt;/em> PWM. If you read down further, you&amp;rsquo;ll find&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">pwm_apply_state&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> pwm_device &lt;span style="color:#f92672">*&lt;/span>pwm, &lt;span style="color:#66d9ef">struct&lt;/span> pwm_state &lt;span style="color:#f92672">*&lt;/span>state);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>after no less than 7 links to other functions you need to call first. Continue reading on, and oh! Linux will let you use PWM via &lt;a href="https://en.wikipedia.org/wiki/Sysfs">Sysfs&lt;/a>, just like GPIO and many other systems. The document however won&amp;rsquo;t tell you exactly how to use that interface directly, you&amp;rsquo;ll have to actually &lt;em>read&lt;/em> the document. This upset me, so here&amp;rsquo;s something you can copy and paste.&lt;/p>
&lt;p>The root directory you want to be in is &lt;code>/sys/class/pwm&lt;/code>. To use a PWM output, you&amp;rsquo;ll need to &lt;code>export&lt;/code> it. (replace &lt;code>N&lt;/code> with your PWM chip, and &lt;code>C&lt;/code> with the channel)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#ae81ff">1&lt;/span> &amp;gt; /sys/class/pwm/pwmchipN/export
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In Elixir, we can do&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-elixir" data-lang="elixir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">File&lt;/span>&lt;span style="color:#f92672">.&lt;/span>write!(&lt;span style="color:#e6db74">&amp;#34;/sys/class/pwm/pwmchipN/export&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Next, it must be enabled:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#ae81ff">1&lt;/span> &amp;gt; /sys/class/pwm/pwmchipN/enable
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And you know the deal in Elixir:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-elixir" data-lang="elixir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">File&lt;/span>&lt;span style="color:#f92672">.&lt;/span>write!(&lt;span style="color:#e6db74">&amp;#34;/sys/class/pwm/pwmchipN/export&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Next, you need to set the &lt;code>period&lt;/code> and &lt;code>duty_cycle&lt;/code>. If you don&amp;rsquo;t know what these are, (possibly because you came here from Arduino that doesn&amp;rsquo;t tell you anything about either of these two words), Check &lt;a href="https://en.wikipedia.org/wiki/Pulse-width_modulation">Wikipedia&lt;/a>.&lt;/p>
&lt;p>The short of it is, &lt;code>duty_cycle&lt;/code> is the percentage of time that the signal is active. &lt;code>period&lt;/code> is how long that signal is active. The values provided to Linux are in nanoseconds, so to set a 1 millisecond period, you would do:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#ae81ff">1000000&lt;/span> &amp;gt; /sys/class/pwm/pwmchipN/pwmC/period
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>or in Elixir:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-elixir" data-lang="elixir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">File&lt;/span>&lt;span style="color:#f92672">.&lt;/span>write!(&lt;span style="color:#e6db74">&amp;#34;/sys/class/pwm/pwmchipN/pwmC/period&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;1000000&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And to set the a duty cycle of 50%, you&amp;rsquo;d set the &lt;code>duty_cycle&lt;/code> to half of the &lt;code>period&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#ae81ff">500000&lt;/span> &amp;gt; /sys/class/pwm/pwmchipN/pwmC/duty_cycle
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>or in Elixir:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-elixir" data-lang="elixir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">File&lt;/span>&lt;span style="color:#f92672">.&lt;/span>write!(&lt;span style="color:#e6db74">&amp;#34;/sys/class/pwm/pwmchipN/pwmC/duty_cycle&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;500000&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And that&amp;rsquo;s pretty much it. I encourage you to study the official document further, it may be a little dense, but all the information you need &lt;em>is&lt;/em> there. Hopefully this helped someone along their way to controlling something interesting with PWM.&lt;/p>
&lt;h2 id="bonus-round-rgb-led-control">Bonus Round: RGB LED control&lt;/h2>
&lt;p>The entire reason, I had to learn this information was to control RGB LEDs for a &lt;a href="https://cone.codes/posts/can-link/">device I&amp;rsquo;m building&lt;/a> to control LEDs based on an engine control unit. This is what I use for that.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-elixir" data-lang="elixir">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">defmodule&lt;/span> &lt;span style="color:#a6e22e">MyApp.RGB&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">alias&lt;/span> &lt;span style="color:#a6e22e">MyApp.PWM&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">use&lt;/span> &lt;span style="color:#a6e22e">GenServer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">require&lt;/span> &lt;span style="color:#a6e22e">Logger&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@all_channels&lt;/span> [&lt;span style="color:#e6db74">:led_r&lt;/span>, &lt;span style="color:#e6db74">:led_g&lt;/span>, &lt;span style="color:#e6db74">:led_b&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> start_link(opts) &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">GenServer&lt;/span>&lt;span style="color:#f92672">.&lt;/span>start_link(__MODULE__, opts, &lt;span style="color:#e6db74">name&lt;/span>: __MODULE__)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> on() &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">GenServer&lt;/span>&lt;span style="color:#f92672">.&lt;/span>call(__MODULE__, &lt;span style="color:#e6db74">:on&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> off() &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">GenServer&lt;/span>&lt;span style="color:#f92672">.&lt;/span>call(__MODULE__, &lt;span style="color:#e6db74">:off&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> set_color(val) &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">GenServer&lt;/span>&lt;span style="color:#f92672">.&lt;/span>call(__MODULE__, {&lt;span style="color:#e6db74">:set_color&lt;/span>, val})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> set_brightness(val) &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">GenServer&lt;/span>&lt;span style="color:#f92672">.&lt;/span>call(__MODULE__, {&lt;span style="color:#e6db74">:set_brightness&lt;/span>, val})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> init(_opts) &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@all_channels&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">Enum&lt;/span>&lt;span style="color:#f92672">.&lt;/span>each(&lt;span style="color:#66d9ef">fn&lt;/span> channel &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">PWM&lt;/span>&lt;span style="color:#f92672">.&lt;/span>enable(channel, &lt;span style="color:#66d9ef">false&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state &lt;span style="color:#f92672">=&lt;/span> %{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">color&lt;/span>: &lt;span style="color:#e6db74">:white&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">brightness&lt;/span>: &lt;span style="color:#ae81ff">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">:ok&lt;/span>, state}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> handle_call(&lt;span style="color:#e6db74">:on&lt;/span>, _from, state) &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> set(state&lt;span style="color:#f92672">.&lt;/span>color, state&lt;span style="color:#f92672">.&lt;/span>brightness)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@all_channels&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">Enum&lt;/span>&lt;span style="color:#f92672">.&lt;/span>each(&lt;span style="color:#66d9ef">fn&lt;/span> channel &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">PWM&lt;/span>&lt;span style="color:#f92672">.&lt;/span>enable(channel, &lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">:reply&lt;/span>, &lt;span style="color:#e6db74">:ok&lt;/span>, state}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> handle_call(&lt;span style="color:#e6db74">:off&lt;/span>, _from, state) &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@all_channels&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">Enum&lt;/span>&lt;span style="color:#f92672">.&lt;/span>each(&lt;span style="color:#66d9ef">fn&lt;/span> channel &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">PWM&lt;/span>&lt;span style="color:#f92672">.&lt;/span>enable(channel, &lt;span style="color:#66d9ef">false&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">:reply&lt;/span>, &lt;span style="color:#e6db74">:ok&lt;/span>, state}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> handle_call({&lt;span style="color:#e6db74">:set_color&lt;/span>, val}, _from, state) &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> set(val, state&lt;span style="color:#f92672">.&lt;/span>brightness)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">:reply&lt;/span>, &lt;span style="color:#e6db74">:ok&lt;/span>, %{state &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">color&lt;/span>: val}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> handle_call({&lt;span style="color:#e6db74">:set_brightness&lt;/span>, val}, _from, state) &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> set(state&lt;span style="color:#f92672">.&lt;/span>color, val)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">:reply&lt;/span>, &lt;span style="color:#e6db74">:ok&lt;/span>, %{state &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#e6db74">brightness&lt;/span>: val}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defp&lt;/span> set(color, brightness) &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rgb_val &lt;span style="color:#f92672">=&lt;/span> rgb_from_color(color, brightness)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Enum&lt;/span>&lt;span style="color:#f92672">.&lt;/span>zip([&lt;span style="color:#e6db74">:led_r&lt;/span>, &lt;span style="color:#e6db74">:led_g&lt;/span>, &lt;span style="color:#e6db74">:led_b&lt;/span>], rgb_val)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">Enum&lt;/span>&lt;span style="color:#f92672">.&lt;/span>each(&lt;span style="color:#66d9ef">fn&lt;/span> {channel, val} &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> duty_cycle &lt;span style="color:#f92672">=&lt;/span> floor(&lt;span style="color:#a6e22e">PWM&lt;/span>&lt;span style="color:#f92672">.&lt;/span>period(channel) &lt;span style="color:#f92672">*&lt;/span> val &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">255&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">PWM&lt;/span>&lt;span style="color:#f92672">.&lt;/span>duty_cycle(channel, duty_cycle)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defp&lt;/span> rgb_from_color(val, brightness) &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">255&lt;/span> &lt;span style="color:#f92672">*&lt;/span> brightness &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> val &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">:white&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> [max, max, max]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">:red&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> [max, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">:green&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> [&lt;span style="color:#ae81ff">0&lt;/span>, max, &lt;span style="color:#ae81ff">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">:blue&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> [&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, max]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">:yellow&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> [max, max, &lt;span style="color:#ae81ff">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">:cyan&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> [&lt;span style="color:#ae81ff">0&lt;/span>, max, max]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">:magenta&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> [max, &lt;span style="color:#ae81ff">0&lt;/span>, max]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {r, g, b} &lt;span style="color:#f92672">-&amp;gt;&lt;/span> [r, g, b]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [r, g, b] &lt;span style="color:#f92672">-&amp;gt;&lt;/span> [r, g, b]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>CAN Link</title><link>https://cone.codes/posts/can-link/</link><pubDate>Fri, 01 Apr 2022 23:17:51 -0600</pubDate><guid>https://cone.codes/posts/can-link/</guid><description>I&amp;rsquo;ve been working on an idea off and on for the last year or so, and it&amp;rsquo;s finally culminated into a real thing that exists. What I want is a device that can interface an aftermarket ECU in my car, and mesh network with other nodes to syncronize RGB LEDs. This is of course a silly idea and would not make a real sustainable product or business, but I think it&amp;rsquo;s fun.</description><content>&lt;p>I&amp;rsquo;ve been working on an idea off and on for the last year or so, and it&amp;rsquo;s finally culminated
into a real thing that exists. What I want is a device that can interface an aftermarket
&lt;a href="https://en.wikipedia.org/wiki/Electronic_control_unit">ECU&lt;/a> in my car, and mesh network with
other nodes to syncronize RGB LEDs. This is of course a silly idea and would not make a real
sustainable product or business, but I think it&amp;rsquo;s fun.&lt;/p>
&lt;p>Like I said, I&amp;rsquo;ve been working on this for quite a while, so there&amp;rsquo;s quite a bit to catch up
on. Instead of blabbing about the software (which will be blabbed about in the future), I&amp;rsquo;m
gonna write up a quick summary of my experience doing an entire PCB &amp;ldquo;from scratch&amp;rdquo;, since that&amp;rsquo;s
the most recent portion of the project I&amp;rsquo;ve completed.&lt;/p>
&lt;h2 id="designing-pcb-for-nerves-firmware">Designing PCB for Nerves Firmware&lt;/h2>
&lt;p>I picked the BeagleBoneBlue as my development board because it had &lt;em>almost&lt;/em> all the stuff I
wanted for the final design. It also uses the &lt;a href="https://octavosystems.com/octavo_products/osd335x/">OSD335x&lt;/a> CPU, which is a very well supported device in the Nerves world. I
use it for my current work product, I&amp;rsquo;ve worked with other companies using Nerves that use it,
etc.&lt;/p>
&lt;p>The first step (after making a prototype ofc) was to make the schematic. Another reason I picked
this devboard was beause of how simple it is. The entire schematic is 5 pages long, and fits
into a single PDF. &lt;a href="https://github.com/beagleboard/beaglebone-blue/blob/9812bd927a0157a0a326debb858e36678e6eed64/BeagleBone_Blue_sch.pdf">Here it is&lt;/a>.
I &lt;a href="https://github.com/miata-bot/can-link/commit/69d136ebbe92c61059c85afc6919afc3817271a1">tricked a friend of mine into importing it into kicad&lt;/a> for me, then got to modifying it.&lt;/p>
&lt;h2 id="the-schematic">The Schematic&lt;/h2>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/643947340453118019/958716169408352256/unknown.png?width=2160&amp;amp;height=864" alt="schematic">&lt;/p>
&lt;p>The easy part was removing things I didn&amp;rsquo;t need:&lt;/p>
&lt;ul>
&lt;li>EMMC - I plan on using an SD card for this. It&amp;rsquo;s just easier.&lt;/li>
&lt;li>GPIO connectors - I wanted to keep these, but routing was just too hard for me.&lt;/li>
&lt;li>Motor controllers - No motor to control&lt;/li>
&lt;/ul>
&lt;p>Next up was to change out some parts:&lt;/p>
&lt;ul>
&lt;li>Barrel jack changed for a somewhat standard connector used by many aftermarket ECUs.&lt;/li>
&lt;li>USB Mini changed out for a USB C connector - this port is used for firmware debugging&lt;/li>
&lt;li>USB A changed out for USB B - this port is used for a mass storage gadget&lt;/li>
&lt;li>Battery connector changed out for one that I happen to have.&lt;/li>
&lt;li>Changed all the passives out for bigger packages. This was because I&amp;rsquo;m hand soldering it.&lt;/li>
&lt;/ul>
&lt;p>And finally I added some parts:&lt;/p>
&lt;ul>
&lt;li>JST connector for GPS modules&lt;/li>
&lt;li>3 Mosfets - used for PWMing the RGB LEDs&lt;/li>
&lt;li>RF69 Packet radio - used for syncing devices without internet&lt;/li>
&lt;li>TAG Connect serial console - used for firmware debugging&lt;/li>
&lt;/ul>
&lt;p>And that&amp;rsquo;s it. Pretty much everything else was a standard BeagleBone Blue. I moved some pins
during routing after consulting the datasheet.&lt;/p>
&lt;h2 id="the-layout">The Layout&lt;/h2>
&lt;p>After the schematic was mostly together, next up was to lay all the components out. I picked 0603 and 0805 size packages for everything, and laid all the components on the top side. I&amp;rsquo;m no expert so anyone with real experience in Electrical Engineering will probably have something to say. I guess here is a good place to put: if you, the reader use this for something and it doesn&amp;rsquo;t work; sorry and also I&amp;rsquo;m not responsible for whatever happens.&lt;/p>
&lt;p>I started out with just plopping everything down.&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/643947340453118019/958094663275925524/unknown.png" alt="layout">.&lt;/p>
&lt;p>The first goal was to make sure I have 3d models for every part. I know it seems overkill, but it
just helps me with part placement to be able to visualize things. Kicad&amp;rsquo;s 3d viewer is pretty good once you get the models loaded. If you don&amp;rsquo;t do this, you really should.&lt;/p>
&lt;p>Next I sorted the components out into their respective &amp;ldquo;systems&amp;rdquo;. Decoupling caps per device, pullup/pulldown resistors in some sort of structure, power components, radio, connectors etc.
The goal here is to make sure there&amp;rsquo;s room on the board for everything and to start thinking of everything in relationship to the other components. A good layout here is going to pay off later when it comes to routing.&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/643947340453118019/958814194273243146/unknown.png" alt="layout-progress">&lt;/p>
&lt;p>What happens next is sort of non-linear. I pretty much just arbitrarily started pecking around
the design, juggling parts around into the correct general shape so it can be moved around as a unit. I didn&amp;rsquo;t have an requirements for where anything should go, which was sort of hard for me to reason about, so I just started assembling sections into blocks.&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/643947340453118019/958883714396487722/unknown.png" alt="layout-progress">&lt;/p>
&lt;p>The general layout started to take place at this point. The WiFi module was laid out and placed permenantly at the edge of the board. The RF69 radio goes right under it.
Right around this point is when I put some serious thought into how the device should look and
feel when it exists in the real world. I moved the connectors around, made cardboard boxes in about the same shape, etc. Just to see how it would feel to actually use.&lt;/p>
&lt;p>Eventually, I decided that the USB and CAN interfaces should be on the right. This is where power
and CAN signal are provided to the board. Technically, that is all that is required to run the device.&lt;/p>
&lt;p>&lt;img src="https://cdn.discordapp.com/attachments/643947340453118019/959123883582169098/unknown.png" alt="connectors">&lt;/p>
&lt;h2 id="the-routing">The Routing&lt;/h2>
&lt;p>After all the main systems were layed out on the board, it was time to route the board. This is
the second BGA package I&amp;rsquo;ve fanned out, and this one was far larger than the last. I did what
I think is an okay job. I&amp;rsquo;m certain it could be improved, and I&amp;rsquo;m sure one day I will think this
is the worst thing ever. I ended up removing a bunch of extra stuff I wanted, but didn&amp;rsquo;t need.
Notably, GPIO connectors, extra buttons and extra LEDs. This is the gist of what I came up with for
fanning the package out.&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/643947340453118019/959291652126679080/unknown.png" alt="fanout">&lt;/p>
&lt;p>While working on that, I took breaks to do other sections that could be built independently.
The WiFi / Bluetooth module was a particularly neat one.&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/643947340453118019/959184408865284156/unknown.png" alt="bluetooth-layout">&lt;/p>
&lt;p>Once I got all the tracks out of the BGA, all that was left was to shuffle all the signals
to where they needed to go. If I were to do it over again, I&amp;rsquo;d move the SD Card over to the right
side of the board. I originally put the SD Card on the top of the board thinking I could fan the
MMC pins that direction. I don&amp;rsquo;t remember exactly why i couldn&amp;rsquo;t, but I think it was because
of the big power pours.&lt;/p>
&lt;p>This is pretty much the final layout and routing.&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/643947340453118019/959527063302307960/unknown.png" alt="final-layout-routing">&lt;/p>
&lt;p>Lastly, I sprinkled some text, a logo, and connector descriptions onto the silkscreen.&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/957852929254113300/959576291563163708/unknown.png" alt="final-pcb-model">&lt;/p>
&lt;p>And that&amp;rsquo;s pretty much as far as I got this weekend. Next up is to pick out each of the individual components.
One notable issue with that is there&amp;rsquo;s this whole global chip shortage thing..&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/643947340453118019/959626650935517194/unknown.png?width=2160&amp;amp;height=144" alt="chip-shortage">&lt;/p>
&lt;p>I ordered a few OSD335X chips on Aliexpress. Tune back in next week to see if they show up or not.&lt;/p></content></item><item><title>Using HX711 with Linux</title><link>https://cone.codes/posts/linux-hx711/</link><pubDate>Thu, 20 Jan 2022 16:24:27 -0700</pubDate><guid>https://cone.codes/posts/linux-hx711/</guid><description>TLDR Here&amp;rsquo;s the code you probably want. Modify it as you see fit.
loadcell_en_reg: fixedregulator@3 { compatible = &amp;#34;regulator-fixed&amp;#34;; regulator-name = &amp;#34;loadcell-en-regulator&amp;#34;; regulator-min-microvolt = &amp;lt;3300000&amp;gt;; regulator-max-microvolt = &amp;lt;3300000&amp;gt;; /* ADC_PWR_EN */ gpio = &amp;lt;&amp;amp;gpio1 13 0&amp;gt;; enable-active-high; }; hx711: hx711 { compatible = &amp;#34;avia,hx711&amp;#34;; sck-gpios = &amp;lt;&amp;amp;gpio1 14 GPIO_ACTIVE_HIGH&amp;gt;; dout-gpios = &amp;lt;&amp;amp;gpio1 15 GPIO_ACTIVE_HIGH&amp;gt;; avdd-supply = &amp;lt;&amp;amp;loadcell_en_reg&amp;gt;; }; $ cat /sys/bus/iio/devices/iio:device2/in_voltage0_raw 6818404 Using HX711 from Linux The HX711 is a really common device, most commonly used to measure weight via a load cell.</description><content>&lt;h1 id="tldr">TLDR&lt;/h1>
&lt;p>Here&amp;rsquo;s the code you probably want. Modify it as you see fit.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>loadcell_en_reg: fixedregulator&lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> compatible &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;regulator-fixed&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> regulator&lt;span style="color:#f92672">-&lt;/span>name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;loadcell-en-regulator&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> regulator&lt;span style="color:#f92672">-&lt;/span>min&lt;span style="color:#f92672">-&lt;/span>microvolt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">3300000&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> regulator&lt;span style="color:#f92672">-&lt;/span>max&lt;span style="color:#f92672">-&lt;/span>microvolt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">3300000&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* ADC_PWR_EN */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gpio &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;amp;&lt;/span>gpio1 &lt;span style="color:#ae81ff">13&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> enable&lt;span style="color:#f92672">-&lt;/span>active&lt;span style="color:#f92672">-&lt;/span>high;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hx711: hx711 {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> compatible &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;avia,hx711&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sck&lt;span style="color:#f92672">-&lt;/span>gpios &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;amp;&lt;/span>gpio1 &lt;span style="color:#ae81ff">14&lt;/span> GPIO_ACTIVE_HIGH&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dout&lt;span style="color:#f92672">-&lt;/span>gpios &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;amp;&lt;/span>gpio1 &lt;span style="color:#ae81ff">15&lt;/span> GPIO_ACTIVE_HIGH&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> avdd&lt;span style="color:#f92672">-&lt;/span>supply &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;amp;&lt;/span>loadcell_en_reg&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ cat /sys/bus/iio/devices/iio:device2/in_voltage0_raw
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">6818404&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="using-hx711-from-linux">Using HX711 from Linux&lt;/h1>
&lt;p>The HX711 is a really common device, most commonly used to
measure weight via a load cell. It uses a simple 2 wire interface
with a clock and signal. It&amp;rsquo;s not a standard protocol, but simple
anyway.&lt;/p>
&lt;p>You can find devboards at &lt;a href="https://www.sparkfun.com/products/13879">SparkFun&lt;/a>.
You will also probably need a load cell, which can also be found
at &lt;a href="https://www.sparkfun.com/products/13329">SparkFun&lt;/a>.&lt;/p>
&lt;p>There are a ton of implementations out there for using this particular
device:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.arduino.cc/reference/en/libraries/hx711-arduino-library/">Arduino&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/tatobari/hx711py">Python&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.npmjs.com/package/hx711">Javscript&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>But for embedded Linux, none of these are particulary suitable.
Luckily, there is a Linux Kernel Module available for that use
case. &lt;a href="https://github.com/torvalds/linux/blob/master/drivers/iio/adc/hx711.c">Source&lt;/a>&lt;/p>
&lt;p>Unfortunately, as is common with these sorts of devices in Linux, there is almost
no documentation for it besides the
&lt;a href="https://lore.kernel.org/lkml/20170105175156.GA12221@andreas/">Kernel patch&amp;rsquo;s original submission&lt;/a>
and a small blurb in the &lt;a href="https://elixir.bootlin.com/linux/v5.1-rc5/source/Documentation/devicetree/bindings/iio/adc/avia-hx711.txt">Device Tree&lt;/a>.&lt;/p>
&lt;p>By the way, there&amp;rsquo;s a typo in the above document. Don&amp;rsquo;t spend an entire work day
figuring that out like me.&lt;/p>
&lt;h2 id="enable-the-kernel-module">Enable the Kernel Module&lt;/h2>
&lt;p>To use this device with Linux, the first thing you will need to do is enable the
kernel module. The name of the module is &lt;code>CONFIG_HX711&lt;/code>. You can enable it
in the &lt;code>make menuconfig&lt;/code> menu. Use &lt;code>/&lt;/code> to search for it.&lt;/p>
&lt;h2 id="configure-the-device-tree">Configure the Device Tree&lt;/h2>
&lt;p>This is the hardest part for me to getting this device working was setting up the
Device tree. The first section has the code required, but I&amp;rsquo;ll walk thru the parts
that held me up.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span> avdd&lt;span style="color:#f92672">-&lt;/span>supply &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;amp;&lt;/span>loadcell_en_reg&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This was probably the single most time consuming part of the entire project. In my particular
case, the regulator is external too my system regulator.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>loadcell_en_reg: fixedregulator&lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> compatible &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;regulator-fixed&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> regulator&lt;span style="color:#f92672">-&lt;/span>name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;loadcell-en-regulator&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> regulator&lt;span style="color:#f92672">-&lt;/span>min&lt;span style="color:#f92672">-&lt;/span>microvolt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">3300000&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> regulator&lt;span style="color:#f92672">-&lt;/span>max&lt;span style="color:#f92672">-&lt;/span>microvolt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">3300000&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* ADC_PWR_EN */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gpio &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;amp;&lt;/span>gpio1 &lt;span style="color:#ae81ff">13&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> enable&lt;span style="color:#f92672">-&lt;/span>active&lt;span style="color:#f92672">-&lt;/span>high;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This looks pretty simple now that I know what everything does. The trick was finding out
I needed a &lt;code>regulator-fixed&lt;/code> device. I spent a lot of time trying to get a different node
functioning: &lt;a href="https://www.kernel.org/doc/Documentation/devicetree/bindings/regulator/gpio-regulator.txt">regulator-gpio&lt;/a>.
My thought process being&lt;/p>
&lt;blockquote>
&lt;p>I have a regulator, it&amp;rsquo;s enabled by gpio, therefor I must want &lt;code>gpio regulator&lt;/code>.&lt;/p>
&lt;/blockquote>
&lt;p>This turned out to be false, and &lt;code>regulator-fixed&lt;/code> itself actually supports using
&lt;code>gpio&lt;/code> to enable it.&lt;/p>
&lt;h2 id="getting-data-from-the-hx711">Getting Data from the HX711&lt;/h2>
&lt;p>The module uses the &lt;a href="https://www.kernel.org/doc/html/v5.4/driver-api/iio/index.html">&lt;code>iio&lt;/code>&lt;/a>
subsystem. That document was a little overwealming to me, so here&amp;rsquo;s the cheat codes:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>/sys/bus/iio/devices/iio:device2/in_voltage0_raw
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="calibration">Calibration&lt;/h2>
&lt;p>Read that file, it will give you the voltage from the device. This value will need
to be calibrated in userspace as documented by the original author of the driver.
This varries depending on which load cell you have and how your device is positioned in
the real world. I may update this post in the future with how i calibrate the device, for
now you probably want to consult the &lt;a href="https://cdn.sparkfun.com/assets/learn_tutorials/5/4/6/hx711F_EN.pdf">Datasheet&lt;/a>.&lt;/p></content></item></channel></rss>