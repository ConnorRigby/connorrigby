<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>linux on cone.codes</title><link>https://cone.codes/tags/linux/</link><description>Recent content in linux on cone.codes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Creative Commons Attribution 4.0 International</copyright><lastBuildDate>Fri, 01 Apr 2022 23:17:51 -0600</lastBuildDate><atom:link href="https://cone.codes/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Can Link</title><link>https://cone.codes/posts/can-link/</link><pubDate>Fri, 01 Apr 2022 23:17:51 -0600</pubDate><guid>https://cone.codes/posts/can-link/</guid><description>I&amp;rsquo;ve been working on an idea off and on for the last year or so, and it&amp;rsquo;s finally culminated into a real thing that exists. What I want is a device that can interface an aftermarket ECU in my car, and mesh network with other nodes to syncronize RGB LEDs. This is of course a silly idea and would not make a real sustainable product or business, but I think it&amp;rsquo;s fun.</description><content>&lt;p>I&amp;rsquo;ve been working on an idea off and on for the last year or so, and it&amp;rsquo;s finally culminated
into a real thing that exists. What I want is a device that can interface an aftermarket
&lt;a href="https://en.wikipedia.org/wiki/Electronic_control_unit">ECU&lt;/a> in my car, and mesh network with
other nodes to syncronize RGB LEDs. This is of course a silly idea and would not make a real
sustainable product or business, but I think it&amp;rsquo;s fun.&lt;/p>
&lt;p>Like I said, I&amp;rsquo;ve been working on this for quite a while, so there&amp;rsquo;s quite a bit to catch up
on. Instead of blabbing about the software (which will be blabbed about in the future), I&amp;rsquo;m
gonna write up a quick summary of my experience doing an entire PCB &amp;ldquo;from scratch&amp;rdquo;, since that&amp;rsquo;s
the most recent portion of the project I&amp;rsquo;ve completed.&lt;/p>
&lt;h2 id="designing-pcb-for-nerves-firmware">Designing PCB for Nerves Firmware&lt;/h2>
&lt;p>I picked the BeagleBoneBlue as my development board because it had &lt;em>almost&lt;/em> all the stuff I
wanted for the final design. It also uses the &lt;a href="https://octavosystems.com/octavo_products/osd335x/">OSD335x&lt;/a> CPU, which is a very well supported device in the Nerves world. I
use it for my current work product, I&amp;rsquo;ve worked with other companies using Nerves that use it,
etc.&lt;/p>
&lt;p>The first step (after making a prototype ofc) was to make the schematic. Another reason I picked
this devboard was beause of how simple it is. The entire schematic is 5 pages long, and fits
into a single PDF. &lt;a href="https://github.com/beagleboard/beaglebone-blue/blob/9812bd927a0157a0a326debb858e36678e6eed64/BeagleBone_Blue_sch.pdf">Here it is&lt;/a>.
I &lt;a href="https://github.com/miata-bot/can-link/commit/69d136ebbe92c61059c85afc6919afc3817271a1">tricked a friend of mine into importing it into kicad&lt;/a> for me, then got to modifying it.&lt;/p>
&lt;h2 id="the-schematic">The Schematic&lt;/h2>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/643947340453118019/958716169408352256/unknown.png?width=2160&amp;amp;height=864" alt="schematic">&lt;/p>
&lt;p>The easy part was removing things I didn&amp;rsquo;t need:&lt;/p>
&lt;ul>
&lt;li>EMMC - I plan on using an SD card for this. It&amp;rsquo;s just easier.&lt;/li>
&lt;li>GPIO connectors - I wanted to keep these, but routing was just too hard for me.&lt;/li>
&lt;li>Motor controllers - No motor to control&lt;/li>
&lt;/ul>
&lt;p>Next up was to change out some parts:&lt;/p>
&lt;ul>
&lt;li>Barrel jack changed for a somewhat standard connector used by many aftermarket ECUs.&lt;/li>
&lt;li>USB Mini changed out for a USB C connector - this port is used for firmware debugging&lt;/li>
&lt;li>USB A changed out for USB B - this port is used for a mass storage gadget&lt;/li>
&lt;li>Battery connector changed out for one that I happen to have.&lt;/li>
&lt;li>Changed all the passives out for bigger packages. This was because I&amp;rsquo;m hand soldering it.&lt;/li>
&lt;/ul>
&lt;p>And finally I added some parts:&lt;/p>
&lt;ul>
&lt;li>JST connector for GPS modules&lt;/li>
&lt;li>3 Mosfets - used for PWMing the RGB LEDs&lt;/li>
&lt;li>RF69 Packet radio - used for syncing devices without internet&lt;/li>
&lt;li>TAG Connect serial console - used for firmware debugging&lt;/li>
&lt;/ul>
&lt;p>And that&amp;rsquo;s it. Pretty much everything else was a standard BeagleBone Blue. I moved some pins
during routing after consulting the datasheet.&lt;/p>
&lt;h2 id="the-layout">The Layout&lt;/h2>
&lt;p>After the schematic was mostly together, next up was to lay all the components out. I picked 0603 and 0805 size packages for everything, and laid all the components on the top side. I&amp;rsquo;m no expert so anyone with real experience in Electrical Engineering will probably have something to say. I guess here is a good place to put: if you, the reader use this for something and it doesn&amp;rsquo;t work; sorry and also I&amp;rsquo;m not responsible for whatever happens.&lt;/p>
&lt;p>I started out with just plopping everything down.&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/643947340453118019/958094663275925524/unknown.png" alt="layout">.&lt;/p>
&lt;p>The first goal was to make sure I have 3d models for every part. I know it seems overkill, but it
just helps me with part placement to be able to visualize things. Kicad&amp;rsquo;s 3d viewer is pretty good once you get the models loaded. If you don&amp;rsquo;t do this, you really should.&lt;/p>
&lt;p>Next I sorted the components out into their respective &amp;ldquo;systems&amp;rdquo;. Decoupling caps per device, pullup/pulldown resistors in some sort of structure, power components, radio, connectors etc.
The goal here is to make sure there&amp;rsquo;s room on the board for everything and to start thinking of everything in relationship to the other components. A good layout here is going to pay off later when it comes to routing.&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/643947340453118019/958814194273243146/unknown.png" alt="layout-progress">&lt;/p>
&lt;p>What happens next is sort of non-linear. I pretty much just arbitrarily started pecking around
the design, juggling parts around into the correct general shape so it can be moved around as a unit. I didn&amp;rsquo;t have an requirements for where anything should go, which was sort of hard for me to reason about, so I just started assembling sections into blocks.&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/643947340453118019/958883714396487722/unknown.png" alt="layout-progress">&lt;/p>
&lt;p>The general layout started to take place at this point. The WiFi module was laid out and placed permenantly at the edge of the board. The RF69 radio goes right under it.
Right around this point is when I put some serious thought into how the device should look and
feel when it exists in the real world. I moved the connectors around, made cardboard boxes in about the same shape, etc. Just to see how it would feel to actually use.&lt;/p>
&lt;p>Eventually, I decided that the USB and CAN interfaces should be on the right. This is where power
and CAN signal are provided to the board. Technically, that is all that is required to run the device.&lt;/p>
&lt;p>&lt;img src="https://cdn.discordapp.com/attachments/643947340453118019/959123883582169098/unknown.png" alt="connectors">&lt;/p>
&lt;h2 id="the-routing">The Routing&lt;/h2>
&lt;p>After all the main systems were layed out on the board, it was time to route the board. This is
the second BGA package I&amp;rsquo;ve fanned out, and this one was far larger than the last. I did what
I think is an okay job. I&amp;rsquo;m certain it could be improved, and I&amp;rsquo;m sure one day I will think this
is the worst thing ever. I ended up removing a bunch of extra stuff I wanted, but didn&amp;rsquo;t need.
Notably, GPIO connectors, extra buttons and extra LEDs. This is the gist of what I came up with for
fanning the package out.&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/643947340453118019/959291652126679080/unknown.png" alt="fanout">&lt;/p>
&lt;p>While working on that, I took breaks to do other sections that could be built independently.
The WiFi / Bluetooth module was a particularly neat one.&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/643947340453118019/959184408865284156/unknown.png" alt="bluetooth-layout">&lt;/p>
&lt;p>Once I got all the tracks out of the BGA, all that was left was to shuffle all the signals
to where they needed to go. If I were to do it over again, I&amp;rsquo;d move the SD Card over to the right
side of the board. I originally put the SD Card on the top of the board thinking I could fan the
MMC pins that direction. I don&amp;rsquo;t remember exactly why i couldn&amp;rsquo;t, but I think it was because
of the big power pours.&lt;/p>
&lt;p>This is pretty much the final layout and routing.&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/643947340453118019/959527063302307960/unknown.png" alt="final-layout-routing">&lt;/p>
&lt;p>Lastly, I sprinkled some text, a logo, and connector descriptions onto the silkscreen.&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/957852929254113300/959576291563163708/unknown.png" alt="final-pcb-model">&lt;/p>
&lt;p>And that&amp;rsquo;s pretty much as far as I got this weekend. Next up is to pick out each of the individual components.
One notable issue with that is there&amp;rsquo;s this whole global chip shortage thing..&lt;/p>
&lt;p>&lt;img src="https://media.discordapp.net/attachments/643947340453118019/959626650935517194/unknown.png?width=2160&amp;amp;height=144" alt="chip-shortage">&lt;/p>
&lt;p>I ordered a few OSD335X chips on Aliexpress. Tune back in next week to see if they show up or not.&lt;/p></content></item><item><title>Using HX711 with Linux</title><link>https://cone.codes/posts/linux-hx711/</link><pubDate>Thu, 20 Jan 2022 16:24:27 -0700</pubDate><guid>https://cone.codes/posts/linux-hx711/</guid><description>TLDR Here&amp;rsquo;s the code you probably want. Modify it as you see fit.
loadcell_en_reg: fixedregulator@3 { compatible = &amp;#34;regulator-fixed&amp;#34;; regulator-name = &amp;#34;loadcell-en-regulator&amp;#34;; regulator-min-microvolt = &amp;lt;3300000&amp;gt;; regulator-max-microvolt = &amp;lt;3300000&amp;gt;; /* ADC_PWR_EN */ gpio = &amp;lt;&amp;amp;gpio1 13 0&amp;gt;; enable-active-high; }; hx711: hx711 { compatible = &amp;#34;avia,hx711&amp;#34;; sck-gpios = &amp;lt;&amp;amp;gpio1 14 GPIO_ACTIVE_HIGH&amp;gt;; dout-gpios = &amp;lt;&amp;amp;gpio1 15 GPIO_ACTIVE_HIGH&amp;gt;; avdd-supply = &amp;lt;&amp;amp;loadcell_en_reg&amp;gt;; }; $ cat /sys/bus/iio/devices/iio:device2/in_voltage0_raw 6818404 Using HX711 from Linux The HX711 is a really common device, most commonly used to measure weight via a load cell.</description><content>&lt;h1 id="tldr">TLDR&lt;/h1>
&lt;p>Here&amp;rsquo;s the code you probably want. Modify it as you see fit.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>loadcell_en_reg: fixedregulator&lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> compatible &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;regulator-fixed&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> regulator&lt;span style="color:#f92672">-&lt;/span>name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;loadcell-en-regulator&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> regulator&lt;span style="color:#f92672">-&lt;/span>min&lt;span style="color:#f92672">-&lt;/span>microvolt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">3300000&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> regulator&lt;span style="color:#f92672">-&lt;/span>max&lt;span style="color:#f92672">-&lt;/span>microvolt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">3300000&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* ADC_PWR_EN */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gpio &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;amp;&lt;/span>gpio1 &lt;span style="color:#ae81ff">13&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> enable&lt;span style="color:#f92672">-&lt;/span>active&lt;span style="color:#f92672">-&lt;/span>high;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hx711: hx711 {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> compatible &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;avia,hx711&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sck&lt;span style="color:#f92672">-&lt;/span>gpios &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;amp;&lt;/span>gpio1 &lt;span style="color:#ae81ff">14&lt;/span> GPIO_ACTIVE_HIGH&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dout&lt;span style="color:#f92672">-&lt;/span>gpios &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;amp;&lt;/span>gpio1 &lt;span style="color:#ae81ff">15&lt;/span> GPIO_ACTIVE_HIGH&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> avdd&lt;span style="color:#f92672">-&lt;/span>supply &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;amp;&lt;/span>loadcell_en_reg&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ cat /sys/bus/iio/devices/iio:device2/in_voltage0_raw
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">6818404&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="using-hx711-from-linux">Using HX711 from Linux&lt;/h1>
&lt;p>The HX711 is a really common device, most commonly used to
measure weight via a load cell. It uses a simple 2 wire interface
with a clock and signal. It&amp;rsquo;s not a standard protocol, but simple
anyway.&lt;/p>
&lt;p>You can find devboards at &lt;a href="https://www.sparkfun.com/products/13879">SparkFun&lt;/a>.
You will also probably need a load cell, which can also be found
at &lt;a href="https://www.sparkfun.com/products/13329">SparkFun&lt;/a>.&lt;/p>
&lt;p>There are a ton of implementations out there for using this particular
device:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.arduino.cc/reference/en/libraries/hx711-arduino-library/">Arduino&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/tatobari/hx711py">Python&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.npmjs.com/package/hx711">Javscript&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>But for embedded Linux, none of these are particulary suitable.
Luckily, there is a Linux Kernel Module available for that use
case. &lt;a href="https://github.com/torvalds/linux/blob/master/drivers/iio/adc/hx711.c">Source&lt;/a>&lt;/p>
&lt;p>Unfortunately, as is common with these sorts of devices in Linux, there is almost
no documentation for it besides the
&lt;a href="https://lore.kernel.org/lkml/20170105175156.GA12221@andreas/">Kernel patch&amp;rsquo;s original submission&lt;/a>
and a small blurb in the &lt;a href="https://elixir.bootlin.com/linux/v5.1-rc5/source/Documentation/devicetree/bindings/iio/adc/avia-hx711.txt">Device Tree&lt;/a>.&lt;/p>
&lt;p>By the way, there&amp;rsquo;s a typo in the above document. Don&amp;rsquo;t spend an entire work day
figuring that out like me.&lt;/p>
&lt;h2 id="enable-the-kernel-module">Enable the Kernel Module&lt;/h2>
&lt;p>To use this device with Linux, the first thing you will need to do is enable the
kernel module. The name of the module is &lt;code>CONFIG_HX711&lt;/code>. You can enable it
in the &lt;code>make menuconfig&lt;/code> menu. Use &lt;code>/&lt;/code> to search for it.&lt;/p>
&lt;h2 id="configure-the-device-tree">Configure the Device Tree&lt;/h2>
&lt;p>This is the hardest part for me to getting this device working was setting up the
Device tree. The first section has the code required, but I&amp;rsquo;ll walk thru the parts
that held me up.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span> avdd&lt;span style="color:#f92672">-&lt;/span>supply &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;amp;&lt;/span>loadcell_en_reg&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This was probably the single most time consuming part of the entire project. In my particular
case, the regulator is external too my system regulator.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>loadcell_en_reg: fixedregulator&lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> compatible &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;regulator-fixed&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> regulator&lt;span style="color:#f92672">-&lt;/span>name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;loadcell-en-regulator&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> regulator&lt;span style="color:#f92672">-&lt;/span>min&lt;span style="color:#f92672">-&lt;/span>microvolt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">3300000&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> regulator&lt;span style="color:#f92672">-&lt;/span>max&lt;span style="color:#f92672">-&lt;/span>microvolt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">3300000&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* ADC_PWR_EN */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gpio &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;amp;&lt;/span>gpio1 &lt;span style="color:#ae81ff">13&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> enable&lt;span style="color:#f92672">-&lt;/span>active&lt;span style="color:#f92672">-&lt;/span>high;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This looks pretty simple now that I know what everything does. The trick was finding out
I needed a &lt;code>regulator-fixed&lt;/code> device. I spent a lot of time trying to get a different node
functioning: &lt;a href="https://www.kernel.org/doc/Documentation/devicetree/bindings/regulator/gpio-regulator.txt">regulator-gpio&lt;/a>.
My thought process being&lt;/p>
&lt;blockquote>
&lt;p>I have a regulator, it&amp;rsquo;s enabled by gpio, therefor I must want &lt;code>gpio regulator&lt;/code>.&lt;/p>
&lt;/blockquote>
&lt;p>This turned out to be false, and &lt;code>regulator-fixed&lt;/code> itself actually supports using
&lt;code>gpio&lt;/code> to enable it.&lt;/p>
&lt;h2 id="getting-data-from-the-hx711">Getting Data from the HX711&lt;/h2>
&lt;p>The module uses the &lt;a href="https://www.kernel.org/doc/html/v5.4/driver-api/iio/index.html">&lt;code>iio&lt;/code>&lt;/a>
subsystem. That document was a little overwealming to me, so here&amp;rsquo;s the cheat codes:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>/sys/bus/iio/devices/iio:device2/in_voltage0_raw
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="calibration">Calibration&lt;/h2>
&lt;p>Read that file, it will give you the voltage from the device. This value will need
to be calibrated in userspace as documented by the original author of the driver.
This varries depending on which load cell you have and how your device is positioned in
the real world. I may update this post in the future with how i calibrate the device, for
now you probably want to consult the &lt;a href="https://cdn.sparkfun.com/assets/learn_tutorials/5/4/6/hx711F_EN.pdf">Datasheet&lt;/a>.&lt;/p></content></item></channel></rss>